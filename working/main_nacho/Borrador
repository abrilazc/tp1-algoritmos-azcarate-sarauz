6/8

dibujar_nivel() tiene un figura_t * en vez de **
en game agregar un tipo de dato que contenga los puntos y las vidas, pueden estar en nave
-----------------------------------------------------
5/8

TDA nivel
TDA destructible
TDA bala
TDA pantalla (falta .h)

--------------------------------------------------
4/8
mover camara:
si no es infinito solo escalamos.

camara: polilinea fragmento del nivel entero.

si el nivel es infinito:
colocar polilinea:
tomar la polilinea, multiplicarla por 3, sumarle la mitad del alto
Escalar:
medir extremos en y, medir extremos en x,
que quede la pantalla con el minimo de la polilinea en el piso y el maximo auna distancia del amrgensuperior

establecer un cuadrado.
a medida que hay movimiento chequea si golpea contra el margen
si golpea contra el margen se mueve
si el movimiento es mayor a ancho de la polilinea


------------------
figura_t **memoria=crear_figuras(f);
figura_t **figuras_icono=cargar_tipo(memoria,ICONO);
figura_t **figuras_nivel=cargar_tipo(memoria,NIVEL);
figura_t **figuras_sprite=cargar_tipo(memoria,SPRITE);
figura_t **figura_planeta=cargar_tipo(memoria,PLANETA);
figura_t **figura_base=cargar_tipo(memoria,BASE);
figura_t **figura_combustible=cargar_tipo(memoria,COMBUSTIBLE);
figura_t **figura_torreta=cargar_tipo(memoria,TORRETA);
figura_t **figura_reactor=cargar_tipo(memoria,REACTOR);

...

define MAX_TIPOS 8

figura_t **memoria=crear_figuras(f);
figura_t ***lista_figuras=malloc(sizeof(lista_figuras **)*8);
for(size_t i=0;i<MAX_TIPOS;i++){
lista_figuras[i]=cargar_tipo(i);
}


//Borrador
iniciar juego
    cargar todo a memoria;
    cargar tipo niveles (copia);
    cargar tipo planeta (copia);

dibujar_inicio
    dibujar base;
    dibujar estrella;
    dibujar planeta;

iteraciones:
    tecla
    nave: direccion,aceleracion, velocidad, posicion, combustible,
    colision contra:
        paredes: cambia direccion velociddad colision
        sol: pierde una vida, vuelve a base
        planeta: carga planeta contra el que choco

planeta:
    carga elementos
    dibuja
    acomoda camara
    empieza iteraciones

    iteraciones planeta:
    tecla
    nave: aceleracion, velocidad, posicion, direccion, combustible,
    torreta: cantidad y cuales siguen.
    tanque: cantidad y cuales siguen.
    reactor: si sigue estando.
    colisiones:
        Escudo:
            tanque: recarga combustible
        Nave:
            borde pantalla:
                tipo no infinito:
                    cualquier borde:
                        funcion_cambiar nivel: chequear si terminó el nivel e ir a pantalla principal
                tipo infinito:
                    borde superior:
                        acomodar pantalla (hasta cota maxima);
                        cota maxima: funcion cambiar nivel
                    borde lateral:
                        acomodar pantalla
            polilinea planeta:
                pierde una vida y regresa a la posicion inicial si tiene vidas todavia;
                la funcion perder vida debe chequear que tenga vidas todavia
             disparo:
                pierde una vida y regresa a la posicion inicial si tiene vidas todavia;
                la funcion perder vida debe chequear que tenga vidas todavia
        Torreta: disparo;
        Reactor: disparo;


//Dibujo de polilineas

bool dibujar_polilineas(char *nombre,size_t escalado,float posicion[2]){
    figura_t *dibujo=cargar(nombre);//llamarlo por nombre o por figura?
    size_t cant_poli=figura->cantidad_polilineas;
    for(size_t i=0,i<cant_poli,i++){
        polilinea_t *poli_dibu=figura->polilineas[i];
        size_t cant_punt=polilinea_cantidad_puntos(poli_dibu);
        float matriz[2][cant_punt];//revisar que esto sea legal
        for(size_t j=0,j<cant_punt,j++){
            //if(lodeabajo==0) return NULL;
            polilinea_obtener_punto(poli_dibu,j,matriz[0][i],matriz[1][i]);// asi es la firma -> float *x, float *y
        }
        //existe polilinea_setear_color(polilinea_t *polilinea, color_t color)
        //pero no le encuentro mucho sentido...
        uint8_t r, g, b;
        color_a_rgb(poli_dibu->color, &r, &g, &b); //en funciones.h habría que hacer #include "color.h"
        SDL_SetRenderDrawColor(renderer, 0xFF, r, g, b);
        //arreglar matriz[][] de las cosas de abajo
        SDL_RenderDrawLine(render,(matriz[i][0]+posicion[0])*escalado,-(matriz[i][1]+posicion[1])*escalado,(matriz[i+1][0]+posicion[0])*escalado,-(matriz[i+1][1]+posicion[1])*escalado);
    }
    return true;
}

//


//esta es la estructura propuesta del main
SDL_SetRenderDrawColor(renderer, 0xFF, 0x00, 0x00, 0x00);
            for(int i = 0; i < chorro_tam - 1; i++)
                SDL_RenderDrawLine(
                    renderer,
                    chorro[i][0] * f + VENTANA_ANCHO / 2,
                    -chorro[i][1] * f + VENTANA_ALTO / 2,
                    chorro[i+1][0] * f + VENTANA_ANCHO / 2,
                    -chorro[i+1][1] * f + VENTANA_ALTO / 2
                );
        }


struct memoria_niveles;
typedef struct memoria_niveles mem_niv_t;

mem_niv_t crear_memoria_nivel(figura_t **memoria){

}

struct memoria_niveles{
    nivel_t **niveles;
    size_t cantidad;
}


struct nivel;
typedef struc nivel nivel_t;

typedef struct{
bool infinito;
polilinea_t **polilinea;
tanque_t *tanque;
torreta_t *torreta;
reactor_t *reactor;
}nivel_t

nivel_t crear_nivel()

struct tanque;
typedef struct_tanque tanque_t;
struct torreta;
typedef struct_torreta torreta_t;
struct reactor;
typedef struct_reactor reactor_t;

typedef struct{
bool infinito;
polilinea_t **polilinea;
float *posicion[2] //se pueden poner los 3 en parametros disttintos, o los 3 en el mismo
float *angulo;
size_t cantidad;
}tanque_t

typedef struct{
bool infinito;
polilinea_t **polilinea;
float *posicion[2] //se pueden poner los 3 en parametros disttintos, o los 3 en el mismo
float *angulo;
size_t cantidad;
}torreta_t

typedef struct{
bool infinito;
polilinea_t **polilinea;
float *posicion[2] //se pueden poner los 3 en parametros disttintos, o los 3 en el mismo
float *angulo;
size_t cantidad;
}reactor_t

tanque_t crear_tanques(nivel_t nivel){
    pedir cantidad
    pedir memoria
    setear
    setarposicion
}




nivel(nivel_t,nave_t)

matriz tanque x,y,tita
matriz torreta x,y,tita
matriz reactor x,y,tita

cargar nave
cargar superficie
cargar generico(posicion, angulo, cantidad)
generico=tanques, torretas o reactor

tda tanque
posicion
angulo
polilinea
cantidad